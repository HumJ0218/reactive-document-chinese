# 附录A：经典IO流的问题所在

在[关键类型](02_KeyTypes.md#what-about-streams)章节中，我提到`System.IO.Stream`并不适合用来模拟我们在Rx中处理的事件流。本附录将解释原因。

`System.IO.Stream`所代表的抽象是作为操作系统使应用程序代码能够与可以接收和/或产生字节流的设备通信的一种方式而设计的。这使得它们很适合模拟当时普遍存在的[卷带式磁带存储设备](https://en.wikipedia.org/wiki/IBM_7-track)，但如果你只是想表示一个值的序列，这种模型就显得过于繁琐。多年来，流已经被用来表示越来越多样化的事物，包括文件、键盘、网络连接和操作系统状态信息，这意味着到了.NET在2002年出现时，它的`Stream`类型需要混合功能以适应一些相当不同的场景。由于并非所有流都是相同的，一些功能可能不适用于某些流，这种情况相当普遍。

IO流被设计为支持高容量字节数据的高效传递，常与本质上以大块数据工作的设备相结合。在它们被设计的主要场景中，读写操作会涉及调用操作系统API，这些API通常相对昂贵，因此基本的读写操作预期以字节数组形式进行（如果你进行一次系统调用以传输数千字节，那么这一次调用的开销远低于一次一字节的工作方式）。虽然这对效率来说是好事，但对开发人员来说可能不方便（如果你希望使用流来纯粹代表不需要进行系统调用的进程内事件流，因此无法享受这种性能/便利性权衡的好处，这可能会令人恼火）。

有一种标准的权宜之计：向应用程序代码呈现流的库通常不直接代表底层的OS流。相反，它们通常是_缓冲的_，这意味着库将以相对较大的块进行读取，并将最近获取的字节保存在内存中，直到应用程序代码请求它们为止。这可以使像.NET的单字节[`Stream.ReadByte`](https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.readbyte)方法这样的方法工作得相当有效：对该方法的几千次调用可能只导致一次对操作系统API的调用，该API提供对流所代表的任何物理设备的访问。同样，如果你向IO流发送数据，一个缓冲流将等到你提供了一定数量的数据（4096字节是某些.NET `Stream`的常见默认设置）后才实际发送数据到其目标。

但这对我们在Rx中表示的事件源类型可能是一个严重问题。如果IO流故意让你与数据的实际移动隔离开来，这可能引入延迟，这在金融应用程序中可能是灾难性的，因为信息的传递和接收的延迟可能产生巨大的经济后果。即使没有直接的经济影响，这种缓冲在表示用户界面中的事件时也是不合适的。没有人希望在应用程序开始响应该输入之前，必须点击按钮几千次。

还有一个问题是你并不总是知道你得到了哪种类型的流。如果你确切知道你拥有一个表示磁盘上文件的未缓冲流（因为你自己创建了这个流），你通常会编写与你知道你拥有一个缓冲流时完全不同的代码。但如果你编写了一个接受`Stream`参数的方法，你就不清楚你得到了什么，所以你不一定知道哪种编码策略最好。

另一个问题是，由于它们是面向字节的，没有一种`System.IO.Stream`可以产生更复杂的值。如果你想要一个`int`值的流（这不比字节流的想法复杂多少），`System.IO.Stream`对你没有帮助，直到最近这甚至可能阻碍你。如果你使用正常的`Read`或`ReadAsync`方法，你可以尝试一次读四个字节，但`System.IO.Stream`可以决定它只返回三个。（流被允许以这种方式小气的原因是原始设计假设一个流代表了某种固有以固定大小数据单元工作的底层设备。磁盘驱动器和固态硬盘不能读取或写入单个字节；相反，每项操作都涉及某些整数个“扇区”，每个扇区有数百或数千字节长。因此，读操作可能根本无法给你提供你所要求的确切字节数。这也适用于表示通过网络传入数据的流：这样的流可能已经接收到了一些数据，但少于你所要求的，并且它们可能决定返回它们已经拥有的数据，而不是让你等待直到下一条网络信息到达）。现在这是消费代码的问题，需要弄清楚如何处理这个问题。.NET 7.0最终在大约`Stream`首次出现后的二十年解决了这个问题，增加了[`ReadExactly`](https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.readexactly)和[`ReadExactlyAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.readexactlyasync)方法，但如果你必须面向.NET Framework，这些方法是无法使用的，你仍然需要自己解决这个问题。

即使你使用了新方法（或者你编写了包装器来处理由`Stream`作为磁带存储设备抽象的起源引起的这些问题），还是存在短处。如果你希望类型系统帮助你区分`int`值流和`float`值流，`Stream`无济于事。你将需要一种具有类型参数的不同抽象。像`IObservable<T>`这样的东西。我们确切知道从`IObservable<T>`预期得到什么形状的数据，这对使它支持的许多LINQ操作符变得实用至关重要。

另一个可能导致混淆的来源是Unix的“一切皆文件”的设计特性。操作系统通过与文件相同的OS抽象来表示各种事物，这简化了OS设计，并且在某些情况下使你能够以创造性的方式应用最初为文件设计的工具。但缺点是一些流很挑剔。你可能会得到一个看起来与.NET类型系统中的其他流没有区别的流，但只有在你以某种特定大小的块读取或写入时才能工作。

相反地，Rx对于可观察源如何与其订阅者互动的严格定义的规则意味着我们确切知道我们站在哪里。

流可能如何支持多个订阅者并没有一个清晰的模型。像Unix的`tail`命令之类的程序能够“跟随”文件的变化，但它们实现这一点的方式与两个观察者都调用`Subscribe`的方式完全不同。

而这些仅仅是消费者端的问题。如果你想实现一个事件源作为`Stream`，那也不太有趣。为了实现你自己的派生自`Stream`的类型，你需要实现它定义的所有十个抽象成员：5个属性和5个方法。这与`System.Reactive`提供实现Rx事件源的简单方法相去甚远。